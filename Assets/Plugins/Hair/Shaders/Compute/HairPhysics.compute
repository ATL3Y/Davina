#pragma kernel Startup
#pragma kernel Simulate
#pragma kernel Constrains

struct Body
{
	float3 guidePosition;
	float3 position;
	float3 lastPosition;
	float radius;
};

struct GuideJoint
{
	int bodyId;
	float pover;
};

uint sizeY;
float gravity;
float drag;
float elasticyRoot;
float elasticyTip;
float4 wind;
float4x4 transform;

RWStructuredBuffer<Body> bodiesBuffer;
RWStructuredBuffer<Body> staticBodiesBuffer;
RWStructuredBuffer<GuideJoint> guideJointsBuffer;

float CalculateElasticy(uint y)
{
	float t = (float)y/sizeY;
	float expo = pow(2, -10*t);
    return lerp(elasticyTip, elasticyRoot, expo);
}

float3 ToWorld(float3 position)
{
	return mul(transform, float4(position, 1.0));
}

Body ApplyTransform(Body body)
{
	body.position = mul(transform, float4(body.guidePosition, 1.0));
	return body;
}

Body Integrate(Body body)
{
	float3 velocity = body.position - body.lastPosition;
	float3 nextPosition = body.position + velocity*drag + float3(0, 0.005f*gravity, 0);
	body.lastPosition = body.position;
	body.position = nextPosition;
	return body;
}

Body WindSolve(Body body)
{
	body.position += wind.xyz;
	return body;
}

Body ForwardJointSolve(Body upperBody, Body body)
{
	float3 upperBodyGuide = ToWorld(upperBody.guidePosition);
	float3 bodyGuide = ToWorld(body.guidePosition);

	float guideDistance = length(upperBodyGuide - bodyGuide);

	float3 relPosition = upperBody.position - body.position;
	float actualDistance = length(relPosition);

	float penetration = (guideDistance - actualDistance)/actualDistance;
	float3 correction = relPosition * penetration;

    body.position -= correction;
    body.lastPosition -= correction*0.9f;

	return body;
}

Body ColisionSolve(Body body, Body staticBody)
{
	float3 relPosition = body.position - staticBody.position;
	float sumRadius = body.radius + staticBody.radius;

	if (length(relPosition) > sumRadius)
		return body;

	float penetration = sumRadius - length(relPosition);
	float3 normal = normalize(relPosition);

	float3 correction = normal*penetration;
    body.position += correction*0.9f;

	return body;
}

Body CollisionsSolve(Body body)
{
	for(uint i = 0; i < staticBodiesBuffer.Length; i++)
	{
		Body staticBody = staticBodiesBuffer[i];
		body = ColisionSolve(body, staticBody);
	}

	return body;
}

Body JoinToGuide(Body body, float elasticy)
{
    float3 correction = body.position - mul(transform, float4(body.guidePosition, 1.0));
    body.position -= correction * elasticy;
	return body;
}

[numthreads(1,1,1)]
void Startup (uint3 id : SV_DispatchThreadID)
{
	uint i = id.y + id.x*sizeY;
	Body body = bodiesBuffer[i];
	body = ApplyTransform(body);
	body.lastPosition = body.position;
	bodiesBuffer[i] = body;
}

[numthreads(1,1,1)]
void Simulate (uint3 id : SV_DispatchThreadID)
{
	uint i = id.y + id.x*sizeY;
	Body body = bodiesBuffer[i];

	if(id.y == 0)//joint list
	{	 
		bodiesBuffer[i] = ApplyTransform(body);
		return;
	}

	body = Integrate(body);
	body = WindSolve(body);
	body = ForwardJointSolve(bodiesBuffer[i - 1], body);
	body = CollisionsSolve(body);
	body = JoinToGuide(body, CalculateElasticy(id.y));

	bodiesBuffer[i] = body;
}

[numthreads(1,1,1)]
void Constrains (uint3 id : SV_DispatchThreadID)
{
	GuideJoint joint = guideJointsBuffer[id.x];
	Body body = bodiesBuffer[joint.bodyId - id.y];
	body = JoinToGuide(body, max(0, joint.pover - id.y*0.2));
	bodiesBuffer[joint.bodyId - id.y] = body;
}








